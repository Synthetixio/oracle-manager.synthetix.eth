{"version":3,"file":"chunk/6462.45ee164e.js","mappings":"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","sources":["webpack://@snx-v3/oracle-manager/../../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/_version.js","webpack://@snx-v3/oracle-manager/../../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/formatter.js","webpack://@snx-v3/oracle-manager/../../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/base-provider.js","webpack://@snx-v3/oracle-manager/../../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","webpack://@snx-v3/oracle-manager/../../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","webpack://@snx-v3/oracle-manager/../../node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/index.js"],"sourcesContent":["export const version = \"providers/5.5.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: address,\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result) {\n    try {\n        return toUtf8String(_parseBytes(result));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            try {\n                return _parseBytes(yield this.provider.call(tx));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const transaction = {\n                        to: this.address,\n                        data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                    };\n                    const hexBytes = yield this.provider.call(transaction);\n                    // No address\n                    if (hexBytes === \"0x\" || hexBytes === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(hexBytes);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [];\n            try {\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    switch (match[1]) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: `https:/\\/gateway.ipfs.io/ipfs/${avatar.substring(7)}` };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (match[1] === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: match[1], content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (match[1] === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (match[1] === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx));\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (match[1] === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            }\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            // Pull the image URL out\n                            if (!metadata || typeof (metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            linkage.push({ type: \"url\", content: metadata.image });\n                            return { linkage, url: metadata.image };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        logger.checkNew(new.target, Provider);\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        const filter = event.filter;\n                        filter.fromBlock = this._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n                        const runner = this.getLogs(filter).then((logs) => {\n                            if (logs.length === 0) {\n                                return;\n                            }\n                            logs.forEach((log) => {\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                this.emit(filter, log);\n                            });\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"call\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const address = yield this._getResolver(name);\n                if (address == null) {\n                    return null;\n                }\n                return new Resolver(this, address, name);\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get the resolver from the blockchain\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n            }\n            // keccak256(\"resolver(bytes32)\")\n            const transaction = {\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            };\n            try {\n                return this.formatter.callAddress(yield this.call(transaction));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resovler\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddress = yield this._getResolver(reverseName);\n            if (!resolverAddress) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            let bytes = arrayify(yield this.call({\n                to: resolverAddress,\n                data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n            }));\n            // Strip off the dynamic string pointer (0x20)\n            if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n                return null;\n            }\n            bytes = bytes.slice(32);\n            // Not a length-prefixed string\n            if (bytes.length < 32) {\n                return null;\n            }\n            // Get the length of the string (from the length-prefix)\n            const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n            bytes = bytes.slice(32);\n            // Length longer than available data\n            if (length > bytes.length) {\n                return null;\n            }\n            const name = toUtf8String(bytes.slice(0, length));\n            // Make sure the reverse record matches the foward record\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(reverseName);\n                if (!resolverAddress) {\n                    return null;\n                }\n                resolver = new Resolver(this, resolverAddress, \"_\", address);\n            }\n            else {\n                // ENS name; forward lookup\n                resolver = yield this.getResolver(nameOrAddress);\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    const transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        logger.checkNew(new.target, JsonRpcSigner);\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        logger.checkNew(new.target, JsonRpcProvider);\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-a559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n//# sourceMappingURL=index.js.map"],"names":["version","logger","Formatter","constructor","checkNew","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","value","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","toNumber","toLowerCase","Error","strict","substring","throwArgumentError","result","length","callAddress","error","_block","format","author","_difficulty","check","gas","isZero","input","chainId","networkId","parseInt","replace","byzantium","Array","isArray","map","static","object","key","checkKey","checkValue","nullValue","replaceValue","array","forEach","push","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","done","then","apply","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","indexOf","isForkEvent","warn","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","listener","once","event","split","comps","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","encode","sha2","matchers","RegExp","_parseString","_parseBytes","offset","Resolver","provider","name","resolvedAddress","formatter","_fetchBytes","selector","parameters","tx","namehash","call","code","errors","CALL_EXCEPTION","_getAddress","coinType","hexBytes","coinInfo","String","throwError","UNSUPPORTED_OPERATION","operation","bytes","match","words","unshift","getAddress","getAvatar","linkage","avatar","getText","i","content","url","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","image","JSON","stringify","getContentHash","ipfs","swarm","keyBytes","defaultFormatter","nextPollId","BaseProvider","network","super","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","NETWORK_ERROR","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","getNetwork","_setFastBlockNumber","poll","pollId","runners","pollingInterval","Math","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","log","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","func","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","eq","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","getGasPrice","SERVER_ERROR","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","_getResolver","ensAddress","resolver","lookupAddress","reverseName","resolverAddress","nameOrAddress","NOT_IMPLEMENTED","_startEvent","_stopEvent","_addEventListener","args","stopped","eventTag","listenerCount","listeners","off","removeAllListeners","found","errorGas","checkError","message","body","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","sender","hexlifyTransaction","signTransaction","signMessage","_legacySignMessage","_signTypedData","domain","types","populated","resolveNames","getPayload","unlock","password","allowedTransactionKeys","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","a","request","id","jsonrpc","action","cache","connection","response","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","StaticJsonRpcProvider","_super","create","get"],"sourceRoot":""}